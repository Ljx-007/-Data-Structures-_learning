#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
//子串的定位运算通常称为串的模式匹配或串匹配，此运算在搜索引擎，拼写检查，语言翻译等应用中使用广泛
//串的模式匹配设有两个字符串S和T，设S为主串，也称正文串；设T为子串，也称为模式。
//在主串S中查找与模式T相匹配的子串，如果匹配成功，确定相匹配的子串中的第一个字符在主串S中出现的位置。

//著名的模式匹配算法有BF算法和KMP算法。
#define MAXSIZE 255
typedef struct
{
	char ch[MAXSIZE + 1];
	int len;
}SString;
int Getlen(char* str)   //从字符串的第1个序号开始计算字符长度
{
	int count = 0;
	int i = 1;
	while (str[i]!='\0')
	{
		count++, i++;
	}
	return count;
}
void InputString(SString* S)
{
	printf("输入一个字符串:");
	scanf("%s", &S->ch[1]);   //从字符串序号1的位置开始输入字符串
	S->len = Getlen(S->ch);
}
//BF算法--英文名Brute-Force，意思是暴力破解，BF算法通过枚举形式暴力求解
//从主串的第一个字符开始与子串比较，如果在子串长度内不相等，则回溯指针，开始第二轮比较，从主串的第二个字符开始与子串一一比较。
int Index_BF(SString* S, SString* T)   //主串为S，子串为T
{  //如果想从主串的第pos个字符开始匹配，则函数增加一个参数int pos ，i从pos开始遍历即可
	int i = 1, j = 1;
	while (i <= S->len && j <= T->len)   //如果超过了字符串长度，说明字符串到尾了，就不比了，
	{
		if (S->ch[i] == T->ch[j])  //如果字符相同，继续往后比
			i++, j++;
		else
		{
			i = i - j + 2;   //主串指针i回溯，指向下一个字符，开始下一轮匹配
			//i-j+2分解为（i-j+1）+1,i-j+1是回到本轮i最开始指向的位置，i-j是减掉已经跳过的字符，+1是因为定义字符串从序号1位置开始
			//再加1是让i指向下一个字符
			j = 1;         //子串指针回溯，指向子串的头部，开始下一轮匹配
		}
	}
	//跳出循环有两种可能
	//1.主串到头了，说明匹配到最后都没有相等的字符串，匹配失败
	//2.子串到头了，说明匹配成功
	if (j > T->len)
		return i-T->len;   //匹配成功，返回主串中含子串的第一个字符下标
	else
		return 0;
}//BF算法在最坏情况下时间复杂度为O(n*m)，n为主串长度，m为模式串长度

//KMP算法
//KMP算法解析：
//KMP算法相较于BF算法时间复杂度低，原因在于每当一趟匹配出现字符比较不等时主串指针i无需回溯，而是利用已经得到的“部分匹配”结果向右滑动尽可能远后继续比较
// i一直往前走，这样时间复杂度呈线性规律，比BF算法低了许多

//KMP算法针对模式串进行研究，针对模式串的当前位置之前的字符串的前缀与后缀是否相等，并寻找最大前后缀，如存在相等的前后缀，则直接把前缀移动到后缀的位置
//  这样就实现了“部分匹配”后的尽可能向右移动
//因此实现模式匹配之前，我们还要找到模式串每一个字符位置的前后缀的最大值并+1（+1是一个规律），这就是发生不匹配时模式串j指针要移动的位置
// 这些位置与主串无关，是模式串本身的性质，于是我们创建next数组，把每个字符发生不匹配时j指针需要移动到的位置存放到next数组中
//  每个字符都有对应的j指针需要移动到的位置序号，把这些位置序号按顺序存放在next数组中
//   当对应字符发生不匹配时通过next数组查表我们就能知道j指针应该移动到什么位置
void Get_next(SString* T, int next[])
{
	int i = 1,j=0;   //i是指针指向字符位置，j是记录字符不匹配时j指针要移动到的位置
	next[1] = 0;   //模式串的第一个字符如果不匹配，则匹配主串的下一个字符，所以第一个字符的j指针等于0，在KMP函数中开始下一个字符的匹配
	while (i < T->len)
	{		
	//这里进入if语句有两种情况
	//1.j==0，模式串的next数组中第一个字符和第二个字符的next数是固定的，next[1]=0,next[2]=1，于是i++指向第二个字符，j++等于1，j指针要移动到的位置为1
	//2.T->ch[i] == T->ch[j]意思是当前字符位置前如果有长度为n的相同前后缀，那么就比较前缀的后一个字符和后缀的后一个字符，如果相等，则最大前后缀长度+1
	//  +1后就是当前字符不匹配时，j指针要移动到的位置
		if (j == 0 || T->ch[i] == T->ch[j])
		{
			i++, j++;
			next[i] = j;
		}
		else
			j = next[j];   //如果前缀的后一个字符和后缀的后一个字符不相等，则j指针跳到所指的字符在next数组中对应的字符位置
		    //因为前后缀的后一个字符不相等，所以前后缀的最大长度不能+1，要重新寻找最大的前后缀长度
		 //KMP算法也可以称看门牌算法，如果发生前后缀后一个字符不匹配的情况，就要找到前后缀的次大值，j则指向该前后缀后一个字符的位置
		 // 寻找次大值的过程就是j=next[j]，通过j当前字符位置对应的门牌，找到j应该跳到的位置，该位置前存在前后缀的次大值
		//看是否有机会让前后缀长度变得更大，如果没有，则继续寻找次大值，以此类推，直到没有前后缀为止，这种思想类似于递归思想
		// 递归思想：
		//比较前后缀的后一个字符，看是否能让前后缀更大（因为我们要找尽可能大的前后缀，让模式串匹配时比较的字符个数越少越好）
		//如果字符不相等，那就再找前后缀次大值，继续比较前后缀后一个字符，如果还不相等，则再找到次次大值，以此类推
	}
}

//next数组的改进--nextval数组
// 我们已知next数组能让j指针跳到前后缀次大值的位置继续比较字符寻找该字符下的最大前后缀
//但当出现AAAAB这样有多个重复字符的模式串要匹配时，会出现重复匹配同样的字符的操作
//例如：  主串：A A A A C A A A A B
//      模式串：A A A A B 
//    next数组：0 1 2 3 4
//当前四个A都匹配成功后，j=5，i=5，最后一个字符B与主串C不匹配，j=next[j]（即j=next[5]）,此时j=4，于是模式串与主串开始匹配的位置变为4
//  主串：A A A A C A A A A B
//模式串：  A A A A B 
//next数组：0 1 2 3 4    
//移动后字符A和C还是不匹配，于是以此类推，j一次一次向后移动，直到j指向模式串最前面的A
//由此我们发现问题，第四个A都与C不匹配了，为什么还要比较第三个第二个第一个A，这是多次一举，所以为了改进这样的情况，我们使用nextval数组代替next
void Get_nextval(SString* T,int nextval[])
{
	int i = 1,j=0;
	nextval[1] = 0;
	while (i < T->len)
	{
		if (j == 0 || T->ch[i] == T->ch[j])      //比较前后缀的后一个字符，相等则进入if语句
		{
			j++, i++;        //前后缀的后一个字符相等，则前后缀长度j就+1
			if (T->ch[i] != T->ch[j])   //此时i指向的字符如果匹配不成功要移动到的位置就是j指向的字符
				//根据我们上述所讲，如果这两个字符相同，那么就没必要再移动，因为i指向的字符已经匹配不成功了，j指向的字符与i指向的字符相等
				// 现在要移动到j指向的字符进行匹配是没有必要的，不需要匹配两次同样的字符，所以不相等的话就按照next数组的处理方式
				nextval[i] = j;
			else   
			//如果相等，则没必要再移动到j指向的的字符进行匹配，此时直接让i指向的字符不匹配时要移动的字符序号指向j指向的字符不匹配时要移动到的字符序号
				nextval[i] = nextval[j];  
		}
		else
			j = nextval[j];
	}
}
int Index_KMP(SString* S, SString* T)
{
	int* next = (int*)malloc(sizeof(int) * (T->len + 1));  //创建一个next数组，来存放模式串下一次要匹配的位置，方便模式串移动到下一次要匹配的位置
	Get_nextval(T,next);
	int i = 1, j = 1;
	while (i <= S->len && j <= T->len)
	{   //进入if语句有两个条件，j==0或者主串和模式串字符匹配，二者满足其一即可进入循环
	//1.j==0时，说明第一个字符就不匹配，于是j和i都++，j++变成1，是让j重新指向模式串头部，因为字符串从位置1开始 
	//  i++是让主串往后移一个字符匹配，因为前一个字符第一个就与模式串不匹配了，所以直接匹配后面的
	//2.S->ch[i] == T->ch[j]时，说明模式串和主串的字符匹配上了，于是匹配下一个字符，所以i++,j++
		if (j == 0 || S->ch[i] == T->ch[j])
			i++, j++;
		else
	//这里进入else语句也有两种情况
	//1.j=1，if判断中模式串第一个字符就与主串不匹配，于是到else，j被next[1]置为0
	//2.j!=1，说明在后续的匹配中出现模式串和主串不匹配的情况，于是j指针移动到next数组所指定的位置，也就是模式串向后移动，移动到j的位置继续与主串匹配
			j = next[j];
	}
	if (j > T->len)
		return i - T->len;
	else
		return 0;
}
int main()
{
	SString S, T;
	InputString(&S);
	InputString(&T);
	int a=Index_KMP(&S, &T);
	if (!a)
		printf("匹配失败\n");
	else
		printf("匹配成功，主串中子串的开始位置为：%d", a);
	return 0;
}