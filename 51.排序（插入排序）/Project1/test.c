#define _CRT_SECURE_NO_WARNINGS 1
//排序
//排序分为多种排序，这里简单介绍几个类型：
//稳定排序：如果排序中有两个元素一模一样，R1和R2，R1在未排序前在R2前面，，若排序后R1仍在R2前，则称稳定排序
//不稳定排序：如果排序后R1在R2后，则称不稳定排序
//内部排序：指待排序记录存放在计算机内存中进行排序
//外部排序：指待排序记录的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。

//待排序记录的存储方式：
//1.顺序表
//2.链表
//3.地址排序：待排序记录本身存储在一组地址连续的存储单元内，同时另设一个指示各个记录存储位置的地址向量，排序的时候不移动记录本身，移动地址向量
//            排序结束后再按照地址向量的值调整记录的存储位置，称为地址排序
//本章讨论除基数排序外，待排序记录均按顺序表存储。
#define MAXSIZE 20
typedef struct
{
	int key;   //关键字假设为int型
	char other;   //其他数据项
}RedType;  //记录的数据类型
typedef struct
{
	RedType r[MAXSIZE + 1];   //r[0]闲置或用作哨兵单元 
	int lenth;
}SqList;
//直接插入排序
void InsertSort(SqList* L)
{
	int i, j;
	for (i = 2; i <= L->lenth; i++)   //直接插入排序首元素无需比较，所以从第二个开始，0号位置闲置做哨兵
	{
		//先判断所排元素是否比前一位大，如果大就不需要排序了，如果小就排序
		if (L->r[i].key < L->r[i - 1].key)
		{
			L->r[0] = L->r[i];  //将要排序的元素放在哨兵位置
			for (j = i - 1; L->r[j].key < L->r[0].key; j--)
			{
				L->r[j+1] = L->r[j];  //将比所排元素大的元素往后搬，知道遇到比所排元素小的元素
			}
			L->r[j+1] = L->r[0];  //出循环后j指向的是比所排元素小的元素，要将所排元素加在其后，所以是j+1
		}
	}
}
//时间复杂度为O(n^2),空间复杂度O(1)

//折半插入排序
//折半插入排序与直接插入排序不同地方在于比较元素大小时不是从后往前依次比较，而是采用二分法来快速寻找到小于等于所排元素的元素
void BInsertSort(SqList* L)
{
	int left, right,mid;
	for (int i = 2; i < L->lenth; i++)
	{
		if(L->r[i-1].key>L->r[i].key)
		{
			left = 1;
			right = i - 1;
			L->r[0] = L->r[i];  //将所排元素放在哨兵位置
			while (left <= right)
			{
				mid = (left + right) / 2;
				if (L->r[mid].key > L->r[0].key)
					right = mid - 1;
				else
					left = mid + 1;
			}
			//right最后停下的位置就是恰好小于所排元素的元素，所以right+1就是我们要插入的位置
			//或者left最后停下的位置就是我们要插入的位置
			for (int j = i - 1; j >= right + 1; j--)
			{
				L->r[j + 1] = L->r[j];  //因为right+1往后的元素都大于所排元素，所以将他们都往后移
			}
			L->r[right + 1] = L->r[0];
		}
	}
}
//平均情况下，折半插入排序减少了元素的比较次数，但元素的移动次数仍不变，所以折半插入排序法时间复杂度仍为O(^2)，空间复杂度为O(1)

//希尔排序
//基本思想：先将整个待排序记录分割成几组，减少参与直接插入排序的数据量，然后对每组分别进行直接插入排序
//           待整个序列中的记录基本有序时，在对全体进行一次直接插入排序
// 希尔排序的分割不是逐段分割，而是将相隔某个“增量”的元素分成一组，例如每隔五个元素就挑出来一个元素，把挑出来的分成一组进行直接插入排序
//全部分组完成后，缩小增量，例如再每隔三个元素挑出来一个元素，把挑出来的分成一组进行直接插入排序，全部分组完成后，继续缩小增量
//最后增量为1，增量为1时相当于直接插入排序。
//特点：
// 1.一次移动，移动位置较大，以跳跃的形式接近排序后的最终位置
// 2.最后一次排序只需要少量移动
// 3.增量序列必须是递减的，且最后一个增量必须为1
// 4.增量序列应该是互质的
void ShellInsert(SqList* L, int dk)   //dk为增量
{   //这里其实与直接插入排序类似，只不过直接插入排序增量为1，这里把1改为了增量dk而已
	int i, j;
	for (i = dk + 1; i < L->lenth; i++)    //i从组内第二个元素开始遍历
	{
		if (L->r[i].key < L->r[i - dk].key)  //如果所排元素小于组内的前一个元素
		{
			L->r[0] = L->r[i];   //将所排元素放入哨兵位置
			for (j = i - dk; L->r[j].key > L->r[0].key && j > 0; j -= dk)   //找到组内小于所排元素的元素，并把大于等于所排元素的元素往后排
			{   //由于增量不为1，所以j减一个增量后可能跳过0位置，所以要多一个条件判断j>0
				L->r[j + dk] = L->r[j];
			}
			L->r[j + dk] = L->r[0];  //最后j+dk的位置就是所排元素该插入的位置
		}
	}
}
void ShellSort(SqList* L, int dlta[], int t)  //dlta数组存放增量序列，t为增量序列的排序趟数
{
	for (int i = 0; i < t; i++)
	{
		ShellInsert(L, dlta[i]);   //对顺序表L中的元素以不同增量进行多次排序，最后达到全部排序完成的目的
	}
}
//希尔排序平均时间复杂度为O(n^1.3)，空间复杂度为O(1)
//不适用于链式存储结构，希尔排序是一个不稳定排序