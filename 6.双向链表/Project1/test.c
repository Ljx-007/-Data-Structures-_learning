#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>
//双向链表
//双向链表就是在单链表的基础上增加一个指向前驱结点的指针
//定义如下
typedef struct DulNode
{
	int data;  //数据域，不一定是int型
	struct DulNode* next, * prior;  //定义一个后继指针和一个前驱指针
}DulNode,*DulList;

//双向链表的头结点的前驱指针为空值，空的双向链表头结点的前驱指针和后继指针都为空值

//双向循环链表
//双向循环链表的尾结点的后继指针指向头结点，因为链表是双向循环的，所以头结点的上一个结点就是尾结点，所以头结点的前驱指针指向尾结点
//双向循环链表的空表的前驱指针和后继指针都指向头结点本身

//双向链表的取值，计算长度，查找元素等操作只需要涉及到一个指针，所以算法与单链表操作相同
//但双向链表的插入和删除有很大不同，因为要同时修改两个指针，时间复杂度均为O(n)

//链表的插入
void InsertList(DulList L,int i)  //要插入的位置i
{
	DulNode* p = L;
	int j = 0;
	while (p && j < i)  //找到第i个元素或者第i-1个元素都可以
	{                  //这里选择找到第i个元素
		p = p->next;
		j++;
	}
	if (!p || j > i)           //查找的步骤可以引用之前的函数GetElem()
	{
		printf("没有此元素！\n");
		return;
	}
	DulNode* s = (DulNode*)malloc(sizeof(DulNode));
	//向s数据域输入数据
	//...
	s->next = p;  //p是指向第i个结点，所以我们要在其前面插入s，所以s的下一个结点是p
	s->prior = p->prior; //s的前驱结点是原来p的前驱结点，所以s的前驱指针指向原来p的前驱指针指向的结点
	//修改完s的前驱指针和后继指针后，还要修改s的前驱结点的后继指针和s的后继结点的前驱指针，使他们都指向s
	p->prior->next = s;   //此时p的前驱指针还指向原来p前面的结点，即s的前驱结点，要把原来p前面的结点的后继指针修改为s
	p->prior = s;  //此时p已经是s的后继结点了再把p的前驱指针修改为s
}

DulNode* GetElem(DulList L, int i)
{
	DulNode* p = L;
	int j = 0;
	while (p && j < i)  //找到第i个元素或者第i-1个元素都可以
	{                  //这里选择找到第i个元素
		p = p->next;
		j++;
	}
	if (!p || j > i)           //查找的步骤可以引用之前的函数GetElem()
	{
		printf("没有此元素！\n");
		return NULL;
	}
	return p;
}
//双向链表的删除
void DelList_Dul(DulList L, int i)  //要删除的结点位置i
{
	DulNode* p = GetElem(L, i);  //先找到第i结点的位置
	if (!p)
		return;
	//开始删除
	p->prior->next=p->next;  //让p的前驱结点的后继指针指向p的后继结点
	p->next->prior = p->prior;  //让p的后继结点的前驱指针指向p的前驱结点
	free(p), p= NULL;
}

//链表和顺序表的比较
//1.顺序表的存储空间必须预先分配，容易造成空间浪费或者溢出
  //而链表不需要预先分配空间，只要内存空间允许，链表的元素个数无限制
  
//2.顺序表的删除和插入都需要移动数据元素
  //而链表的数据元素的逻辑次序靠结点的指针来指示，插入和删除不需要移动元素

//3.顺序表的存储密度为1，存储空间利用率高（存储密度越大，空间利用率越高）    存储密度=数据元素本身占用的存储量/结点结构占用的存储量
  //而链表的存储密度小，每个结点的指针需要占用额外的空间，当数据域占比不大时，指针域所占内存占比大，存储密度就会更小

//4.顺序表可以随机存取，读取某个元素的时间复杂度为O(1)
  //而链表不能随机存取，对任意结点的操作都要从头结点查找到该结点，增加算法复杂度