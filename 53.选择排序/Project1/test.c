#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
#include<stdlib.h>
#define MAXSIZE 20
//选择排序
//简单选择排序
//在表中元素中选出一个最小的，与第一个交换，再选出一个次小的，与第二个交换，以此类推，n-1趟后，排序完成
typedef struct
{
	int key;
	char other;
}RedType;
typedef struct
{
	RedType r[MAXSIZE + 1];//0号位置空闲
	int lenth
}SqList;
void SelectSort(SqList* L)
{
	int k;
	for (int i = 1; i < L->lenth; i++)  //一共有n-1趟
	{
		k = i;  //k最开始指向未排好的元素中的第一个元素
		for (int j = i+1; j <= L->lenth; j++)  //从i元素后一个位置的元素开始与第一个元素i比较
		{
			if (L->r[j].key < L->r[k].key)
				k = j;
		}
		if (k != i)
		{   //将位置i的元素与位置k的元素交换
			L->r[0] = L->r[k];
			L->r[k] = L->r[i];
			L->r[i] = L->r[0];
		}
	}
}
//时间复杂度为O（n^2），空间复杂度为O（1），是一个不稳定排序
//可以用于链式存储结构

//堆排序(Heap Sort)
//堆的定义：
//n个元素的序列{k1,k2,...,kn}称之为堆，当且仅当满足以下条件时：
//（1）ki>=k2i 且 ki>=k2i+1         (2)ki<=k2i 且 ki<=k2i+1
//    大根堆                             小根堆
//可以将堆序列看成是一个完全二叉树，若完全二叉树上的一个结点编号为i，那么它的左右孩子编号为2i和2i+1，恰好符合堆的定义
//所以大根堆可看成是一个根结点最大的完全二叉树，左右孩子都小于根结点
//    小根堆可看成是一个根结点最小的完全二叉树，左右孩子都大于根结点
//堆排序就是将无序序列排成堆序列后，输出堆顶的最小值（或最大值），再将剩下的序列再排成一个堆序列，继续输出次小值（次大值）
// 以此类推得到一个有序序列，称为堆排序

//堆排序要解决两个问题：
//1.如何将无序的元素排列成堆序列？
//2.如何将堆序列剩下的元素重新排成一个堆序列
//先解决第二个问题：
//假设有一个堆序列小根堆（大根堆），先把堆顶元素输出，然后用堆序列中的最后一个元素代替
//  然后将根结点与左右子树的根结点值进行比较，于其中较小（较大）者交换
//   重复上述操作，直至交换到叶子结点，就得到了新的堆，称这个从堆顶至叶子的调整过程为“筛选”

//堆调整，假设序列r[s+1....m]已是堆序列，堆顶元素已经用最后一个元素代替了
// 该函数实现的是筛选的过程，即将用最后一个元素代替堆顶元素后的序列调整成一个堆序列
void HeapAdjust(SqList* L, int s, int m)   //s是序列的堆顶位置，m是堆底位置
{  //这里的堆调整调整的是大根堆
	RedType rc = L->r[s];  //先用rc记录堆顶元素的值
	for (int j = 2 * s; j <= m; j *= 2) //按照堆排序的定义，遍历r[s]的左右孩子，即位置在2*s和2*s+1的元素
	{
		if (j <= m && L->r[j].key < L->r[j + 1].key)   //如果左孩子值大于右孩子，那么令j指向右孩子，j原本等于2*s，++后为2*s+1，指向右孩子
			j++;
		if (rc.key >= L->r[j].key)   //如果堆顶元素的值大于等于左右孩子中较大的那一个元素，说明不需要再进行交换了，直接跳出循环
			break;
		L->r[s] = L->r[j];  //否则将较大的元素与原来的堆顶元素交换位置，这里直接将较大的元素赋值给s位置即可。因为rc已经记录了堆顶元素的值，可以最后再赋值
		s = j;   //再将s位置调整到j位置上，即把堆顶元素的位置换到左右孩子中较大的那个元素的位置上
	}
	L->r[s] = rc;  //出循环后s已经到达合适的位置了，再将原来堆顶元素的值赋值给s位置
}

//解决完第二个问题再来解决第一个问题，如何将无序序列排列成堆序列？
//已知单个结点的树为是堆，只需要将有子树的树调整成堆即可。那么找到有子树的根结点就是关键
// 假设一个无序序列长度为n，那么这个无序序列排列成完全二叉树后，含有子树的最后一个结点的序号为n/2
//  即序号为n/2之后的元素都是叶子结点（单个结点的树），那么n/2之前的元素在完全二叉树中都是含有子树的结点，那么只需要将这些含有子树的结点调整为堆即可
//所以从n/2，n/2-1,n/2-2，....，1。从序号为n/2的结点一直调整到序号为1的结点（根结点），那么无序序列就被排成了堆序列
void CreatHeap(SqList* L)
{
	for (int i = L->lenth / 2; i >= 1; i--)   //从最后一个有子树的根结点调整堆，一直调整到根结点
	{
		HeapAdjust(L, i, L->lenth);
	}
}
//完成堆的建立和堆的调整后就可以进行堆排序了
void HeapSort(SqList* L)
{
	CreatHeap(L);
	for (int i = L->lenth; i >1; i--)  //因为排序要从小到大，而堆调整是调整为从大到小的大根堆，所以for循环从后往前遍历
	{
		RedType k = L->r[1];  //获取大根堆中的堆顶元素，即序列中的最大值
		L->r[1] = L->r[i];   //将最大的元素交换到序列最后
		L->r[i] = k;   //把序列最后的元素交换到第一个位置
		//最大的元素放到最后了，接下来排序剩下的元素
		HeapAdjust(L, 1, i - 1);  //将剩下的元素进行堆调整，继续变成大根堆，再取堆顶最大元素，再放到最后，重复n-1次，元素就被排序好了
	}
}
//时间复杂度为O（nlog2 n），空间复杂度为O（1）
//堆排序是不稳定排序，只能用于顺序存储结构，记录较少时不宜使用，因为建堆所需比较次数较多