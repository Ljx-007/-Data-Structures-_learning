#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//递归通过栈来实现
//函数中再调用函数，最开始调用的函数的参数和返回地址等记录放在栈底，函数中再调用的函数产生的参数和返回地址等记录依次入栈
//当达到递归边界时，数据依次从栈中取出，从递归最里层的数据即栈顶的元素出栈，直至栈底的元素出栈，至此递归结束。

//有些问题可以用递归来解决，如：汉诺塔问题，八皇后问题，迷宫问题等
//例：汉诺塔问题
//假设有3哥分别命名为A,B,C的塔座，在塔座A上插有n个直径大小各不相同，依小到大编号为1，2，... ，n的圆盘。
//现要求将塔座A上的n个圆盘移至塔座C上，并仍按同样的顺序叠排，圆盘移动时必须遵循下列规则：
//1.每次只能移动一个圆盘
//2.圆盘可以插在A,B,C中任一塔座上
//3.任何时刻都不能将一个较大的圆盘压在较小的圆盘之上

//问题分析：
//以三层汉诺塔为例，要完成圆盘按顺序从A移动到C的过程，首先要把最大的圆盘移动到C，移动最大圆盘到C的前提是最大圆盘上面的两个圆盘要移动到B
//两个圆盘移动到B后才能移动最大圆盘，移动完最大圆盘后再处理剩下两个圆盘，将剩下两个圆盘也看做一个汉诺塔问题，这样递归下来，就解决了汉诺塔问题。
//设圆盘数为n
//当n=1时，只需把圆盘从A移到C即可。
//当n=2，则就要借助一根柱子，把最大圆盘上的圆盘移到辅助柱上，然后把最大的圆盘移动到目标柱
//当n=3，同理，借助辅助柱把最大圆盘上的两个圆盘移动到辅助柱上，再把最大圆盘移动到目标柱。把移动两个圆盘看作是n=2时的汉诺塔问题，则能实现移动两个圆盘
//....
//以此类推，可知，要移动n个圆盘就要先移动n-1个圆盘，移动n-1个圆盘就要先移动n-2个圆盘，直到最后先移动1个圆盘

//所以n层汉诺塔问题可以分解为三个小问题
//1.把n-1层移到目标柱B上，此时C做辅助，辅助圆盘移动到B上
//2.把最底层的圆盘移到目标柱C上，此时B做辅助，辅助圆盘移动到C上
//3.把B上的n-1个元素移动到目标柱C上，此时A做辅助，辅助圆盘移动到C上

//算法实现：
void Move(char A, char C)
{
	printf("由塔%c移动到塔%c\n", A, C);
}
void Hanoi(int n, char A, char B, char C)   //目标塔为第四个参数，辅助塔为第三个参数
{
	if (n == 1)
		Move(A, C);  //最上层的圆盘由A移动到C
	else
	{
		Hanoi(n - 1, A, C, B);  //将n-1个圆盘由A移动到B
		Move(A, C);    //将最底下的圆盘由A移动到C
		Hanoi(n - 1, B, A, C);   //将n-1个圆盘由B移动到C
	}
}
int main()
{
	int n = 5;
	char A = 'A';
	char B = 'B';
	char C = 'C';
	Hanoi(3,A,B,C);
	return 0;
}
